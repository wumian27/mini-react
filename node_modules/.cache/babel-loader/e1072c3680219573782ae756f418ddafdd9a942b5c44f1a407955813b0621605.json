{"ast":null,"code":"var _jsxFileName = \"/Users/wujiamian/Desktop/shouxie/mini-react/src/index.js\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// fiber执行阶段\n// 每次渲染都有两个阶段 reconcilation 跟 commit 阶段\n// reconciler： 是diff算法阶段，可以被中断，会找出所有节点的变更\n// 比如节点删除 更新 新增 属性变化， 称为react的副作用\n\n// 提交阶段：将上个阶段计算出来的副作用一次性执行，是同步\n\nconst Comp = /*#__PURE__*/_jsxDEV(\"div\", {\n  id: \"compId\",\n  children: [/*#__PURE__*/_jsxDEV(\"p\", {\n    id: \"text1\",\n    children: [/*#__PURE__*/_jsxDEV(\"p\", {\n      children: \"text1\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 11,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      id: \"text1-1\",\n      children: \"text1-1\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 12,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 10,\n    columnNumber: 5\n  }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n    id: \"text2\",\n    children: \"text2\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 14,\n    columnNumber: 5\n  }, this)]\n}, void 0, true, {\n  fileName: _jsxFileName,\n  lineNumber: 9,\n  columnNumber: 3\n}, this);\n\n// console.log(Comp)\n\nconst root = {\n  stateNode: document.getElementById('root'),\n  props: {\n    children: [Comp]\n  }\n};\nlet nextUnitOfWork = root;\n// 从虚拟DOM跟节点进行遍历，如有浏览器有空闲时间，将进行fiber 节点构建，如果没有，则暂停构建，但nextUnitWork停留在上一次构建的节点\nconst workLoop = deadline => {\n  while (nextUnitOfWork && deadline.timeRemaining() > 0) {\n    nextUnitOfWork = performanceUnitOfWork(nextUnitOfWork);\n  }\n  if (nextUnitOfWork) {\n    requestIdleCallback(workLoop);\n  }\n  // 构建完fiber数 提交，生成真实DOM\n  if (!nextUnitOfWork) {\n    console.log(root);\n    commitRoot(root);\n  }\n};\n\n// TODO: 1.构建真实dom 当不会添加到页面上， 2 构建fiber 结构为 主要结构  {return, child, sibling, props, effectTag, type}\nconst beginWork = workingInProgressFiber => {\n  // 没有真实dom 创建真实dom\n  if (!workingInProgressFiber.stateNode) {\n    workingInProgressFiber.stateNode = document.createElement(workingInProgressFiber.type);\n    for (let key in workingInProgressFiber.props) {\n      // 简单出来将 props 值调添加到dom\n      if (key !== 'children') workingInProgressFiber.stateNode[key] = workingInProgressFiber.props[key];\n    }\n    // 文本简单 处理\n    if (workingInProgressFiber.props && !Array.isArray(workingInProgressFiber.props.children)) {\n      workingInProgressFiber.stateNode.textContent = workingInProgressFiber.props.children;\n    }\n  }\n  if (workingInProgressFiber.props && Array.isArray(workingInProgressFiber.props.children)) {\n    // debugger\n    let previousFiber; // 记录上个fiber 节点\n    workingInProgressFiber.props.children.forEach((child, index) => {\n      // 构建fiber节点信息\n      // debugger\n      const childFiber = {\n        type: child.type,\n        props: child.props,\n        return: workingInProgressFiber,\n        effectTag: 'PLACEMENT'\n      };\n      // 第一元素 是孩子\n      if (index === 0) {\n        workingInProgressFiber.child = childFiber;\n      } else {\n        previousFiber.sibling = childFiber;\n      }\n      previousFiber = childFiber;\n    });\n  }\n};\nconst performanceUnitOfWork = workingInProgressFiber => {\n  beginWork(workingInProgressFiber);\n  // fiber 遍历顺序是 先孩子在sibling 然后到return\n  if (workingInProgressFiber.child) {\n    return workingInProgressFiber.child;\n  }\n  while (workingInProgressFiber) {\n    // 如果没有自孩子 当前节点便利完成\n    // completeUnitOfWork(workingInProgressFiber)\n    // 如果有兄弟节点 返兄弟节点\n    if (workingInProgressFiber.sibling) {\n      return workingInProgressFiber.sibling;\n    }\n    // 没有兄弟节点 回到父级，重新进度while递归 找父级节点的兄弟\n    workingInProgressFiber = workingInProgressFiber.return;\n  }\n};\nconst commitRoot = root => {\n  let currentRoot = root.child;\n  while (currentRoot) {\n    currentRoot.return.stateNode.appendChild(currentRoot.stateNode);\n    currentRoot = currentRoot.child || currentRoot.sibling;\n  }\n};\nrequestIdleCallback(workLoop);","map":{"version":3,"names":["Comp","_jsxDEV","id","children","fileName","_jsxFileName","lineNumber","columnNumber","root","stateNode","document","getElementById","props","nextUnitOfWork","workLoop","deadline","timeRemaining","performanceUnitOfWork","requestIdleCallback","console","log","commitRoot","beginWork","workingInProgressFiber","createElement","type","key","Array","isArray","textContent","previousFiber","forEach","child","index","childFiber","return","effectTag","sibling","currentRoot","appendChild"],"sources":["/Users/wujiamian/Desktop/shouxie/mini-react/src/index.js"],"sourcesContent":["// fiber执行阶段\n// 每次渲染都有两个阶段 reconcilation 跟 commit 阶段\n// reconciler： 是diff算法阶段，可以被中断，会找出所有节点的变更\n// 比如节点删除 更新 新增 属性变化， 称为react的副作用\n\n// 提交阶段：将上个阶段计算出来的副作用一次性执行，是同步\n\nconst Comp = (\n  <div id=\"compId\">\n    <p id=\"text1\">\n      <p>text1</p>\n      <p id=\"text1-1\">text1-1</p>\n    </p>\n    <p id=\"text2\">text2</p>\n  </div>\n)\n\n// console.log(Comp)\n\nconst root = {\n  stateNode: document.getElementById('root'),\n  props: {children: [Comp]}\n}\n\nlet nextUnitOfWork = root\n// 从虚拟DOM跟节点进行遍历，如有浏览器有空闲时间，将进行fiber 节点构建，如果没有，则暂停构建，但nextUnitWork停留在上一次构建的节点\nconst workLoop = (deadline) => {\n\n  while (nextUnitOfWork && deadline.timeRemaining() > 0) {\n    nextUnitOfWork = performanceUnitOfWork(nextUnitOfWork)\n  }\n  if(nextUnitOfWork) {\n    requestIdleCallback(workLoop)\n}\n  // 构建完fiber数 提交，生成真实DOM\n  if(!nextUnitOfWork) {\n    console.log(root)\n    commitRoot(root)\n  }\n}\n\n// TODO: 1.构建真实dom 当不会添加到页面上， 2 构建fiber 结构为 主要结构  {return, child, sibling, props, effectTag, type}\nconst beginWork = (workingInProgressFiber) => {\n\n  // 没有真实dom 创建真实dom\n  if (!workingInProgressFiber.stateNode) {\n    workingInProgressFiber.stateNode = document.createElement(workingInProgressFiber.type)\n    for (let key in workingInProgressFiber.props) {\n      // 简单出来将 props 值调添加到dom\n      if (key !== 'children') workingInProgressFiber.stateNode[key] = workingInProgressFiber.props[key]\n    }\n    // 文本简单 处理\n    if(workingInProgressFiber.props && !Array.isArray(workingInProgressFiber.props.children)) {\n      workingInProgressFiber.stateNode.textContent = workingInProgressFiber.props.children\n    }\n  }\n\n  if (workingInProgressFiber.props && Array.isArray(workingInProgressFiber.props.children)) {\n    // debugger\n    let previousFiber; // 记录上个fiber 节点\n    workingInProgressFiber.props.children.forEach((child, index) => {\n      // 构建fiber节点信息\n      // debugger\n      const childFiber = {\n        type: child.type,\n        props: child.props,\n        return: workingInProgressFiber,\n        effectTag: 'PLACEMENT'\n      }\n      // 第一元素 是孩子\n      if (index === 0) {\n        workingInProgressFiber.child = childFiber\n      } else {\n        previousFiber.sibling = childFiber\n      }\n      previousFiber = childFiber\n    });\n  }\n}\nconst performanceUnitOfWork = (workingInProgressFiber) => {\n  beginWork(workingInProgressFiber)\n  // fiber 遍历顺序是 先孩子在sibling 然后到return\n  if(workingInProgressFiber.child) {\n    return  workingInProgressFiber.child\n  }\n  while(workingInProgressFiber) {\n    // 如果没有自孩子 当前节点便利完成\n    // completeUnitOfWork(workingInProgressFiber)\n    // 如果有兄弟节点 返兄弟节点\n    if(workingInProgressFiber.sibling) {\n      return workingInProgressFiber.sibling\n    }\n  // 没有兄弟节点 回到父级，重新进度while递归 找父级节点的兄弟\n    workingInProgressFiber =  workingInProgressFiber.return\n  }\n}\n\nconst commitRoot = (root) => {\n  let currentRoot = root.child\n  while(currentRoot) {\n     currentRoot.return.stateNode.appendChild(currentRoot.stateNode)\n     currentRoot = currentRoot.child || currentRoot.sibling\n\n  }\n}\nrequestIdleCallback(workLoop)\n"],"mappings":";;AAAA;AACA;AACA;AACA;;AAEA;;AAEA,MAAMA,IAAI,gBACRC,OAAA;EAAKC,EAAE,EAAC,QAAQ;EAAAC,QAAA,gBACdF,OAAA;IAAGC,EAAE,EAAC,OAAO;IAAAC,QAAA,gBACXF,OAAA;MAAAE,QAAA,EAAG;IAAK;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAG,CAAC,eACZN,OAAA;MAAGC,EAAE,EAAC,SAAS;MAAAC,QAAA,EAAC;IAAO;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAG,CAAC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAC1B,CAAC,eACJN,OAAA;IAAGC,EAAE,EAAC,OAAO;IAAAC,QAAA,EAAC;EAAK;IAAAC,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAG,CAAC;AAAA;EAAAH,QAAA,EAAAC,YAAA;EAAAC,UAAA;EAAAC,YAAA;AAAA,OACpB,CACN;;AAED;;AAEA,MAAMC,IAAI,GAAG;EACXC,SAAS,EAAEC,QAAQ,CAACC,cAAc,CAAC,MAAM,CAAC;EAC1CC,KAAK,EAAE;IAACT,QAAQ,EAAE,CAACH,IAAI;EAAC;AAC1B,CAAC;AAED,IAAIa,cAAc,GAAGL,IAAI;AACzB;AACA,MAAMM,QAAQ,GAAIC,QAAQ,IAAK;EAE7B,OAAOF,cAAc,IAAIE,QAAQ,CAACC,aAAa,CAAC,CAAC,GAAG,CAAC,EAAE;IACrDH,cAAc,GAAGI,qBAAqB,CAACJ,cAAc,CAAC;EACxD;EACA,IAAGA,cAAc,EAAE;IACjBK,mBAAmB,CAACJ,QAAQ,CAAC;EACjC;EACE;EACA,IAAG,CAACD,cAAc,EAAE;IAClBM,OAAO,CAACC,GAAG,CAACZ,IAAI,CAAC;IACjBa,UAAU,CAACb,IAAI,CAAC;EAClB;AACF,CAAC;;AAED;AACA,MAAMc,SAAS,GAAIC,sBAAsB,IAAK;EAE5C;EACA,IAAI,CAACA,sBAAsB,CAACd,SAAS,EAAE;IACrCc,sBAAsB,CAACd,SAAS,GAAGC,QAAQ,CAACc,aAAa,CAACD,sBAAsB,CAACE,IAAI,CAAC;IACtF,KAAK,IAAIC,GAAG,IAAIH,sBAAsB,CAACX,KAAK,EAAE;MAC5C;MACA,IAAIc,GAAG,KAAK,UAAU,EAAEH,sBAAsB,CAACd,SAAS,CAACiB,GAAG,CAAC,GAAGH,sBAAsB,CAACX,KAAK,CAACc,GAAG,CAAC;IACnG;IACA;IACA,IAAGH,sBAAsB,CAACX,KAAK,IAAI,CAACe,KAAK,CAACC,OAAO,CAACL,sBAAsB,CAACX,KAAK,CAACT,QAAQ,CAAC,EAAE;MACxFoB,sBAAsB,CAACd,SAAS,CAACoB,WAAW,GAAGN,sBAAsB,CAACX,KAAK,CAACT,QAAQ;IACtF;EACF;EAEA,IAAIoB,sBAAsB,CAACX,KAAK,IAAIe,KAAK,CAACC,OAAO,CAACL,sBAAsB,CAACX,KAAK,CAACT,QAAQ,CAAC,EAAE;IACxF;IACA,IAAI2B,aAAa,CAAC,CAAC;IACnBP,sBAAsB,CAACX,KAAK,CAACT,QAAQ,CAAC4B,OAAO,CAAC,CAACC,KAAK,EAAEC,KAAK,KAAK;MAC9D;MACA;MACA,MAAMC,UAAU,GAAG;QACjBT,IAAI,EAAEO,KAAK,CAACP,IAAI;QAChBb,KAAK,EAAEoB,KAAK,CAACpB,KAAK;QAClBuB,MAAM,EAAEZ,sBAAsB;QAC9Ba,SAAS,EAAE;MACb,CAAC;MACD;MACA,IAAIH,KAAK,KAAK,CAAC,EAAE;QACfV,sBAAsB,CAACS,KAAK,GAAGE,UAAU;MAC3C,CAAC,MAAM;QACLJ,aAAa,CAACO,OAAO,GAAGH,UAAU;MACpC;MACAJ,aAAa,GAAGI,UAAU;IAC5B,CAAC,CAAC;EACJ;AACF,CAAC;AACD,MAAMjB,qBAAqB,GAAIM,sBAAsB,IAAK;EACxDD,SAAS,CAACC,sBAAsB,CAAC;EACjC;EACA,IAAGA,sBAAsB,CAACS,KAAK,EAAE;IAC/B,OAAQT,sBAAsB,CAACS,KAAK;EACtC;EACA,OAAMT,sBAAsB,EAAE;IAC5B;IACA;IACA;IACA,IAAGA,sBAAsB,CAACc,OAAO,EAAE;MACjC,OAAOd,sBAAsB,CAACc,OAAO;IACvC;IACF;IACEd,sBAAsB,GAAIA,sBAAsB,CAACY,MAAM;EACzD;AACF,CAAC;AAED,MAAMd,UAAU,GAAIb,IAAI,IAAK;EAC3B,IAAI8B,WAAW,GAAG9B,IAAI,CAACwB,KAAK;EAC5B,OAAMM,WAAW,EAAE;IAChBA,WAAW,CAACH,MAAM,CAAC1B,SAAS,CAAC8B,WAAW,CAACD,WAAW,CAAC7B,SAAS,CAAC;IAC/D6B,WAAW,GAAGA,WAAW,CAACN,KAAK,IAAIM,WAAW,CAACD,OAAO;EAEzD;AACF,CAAC;AACDnB,mBAAmB,CAACJ,QAAQ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}