{"ast":null,"code":"var _jsxFileName = \"/Users/wujiamian/Desktop/shouxie/mini-react/src/index.js\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// fiber执行阶段\n// 每次渲染都有两个阶段 reconcilation 跟 commit 阶段\n// reconciler： 是diff算法阶段，可以被中断，会找出所有节点的变更\n// 比如节点删除 更新 新增 属性变化， 称为react的副作用\n\n// 提交阶段：将上个阶段计算出来的副作用一次性执行，是同步\n\nconst Comp = /*#__PURE__*/_jsxDEV(\"div\", {\n  id: \"compId\",\n  children: [/*#__PURE__*/_jsxDEV(\"p\", {\n    id: \"text1\",\n    children: [\"text1\", /*#__PURE__*/_jsxDEV(\"p\", {\n      id: \"text1-1\",\n      children: \"text1-1\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 12,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 10,\n    columnNumber: 5\n  }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n    id: \"text2\",\n    children: \"text2\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 14,\n    columnNumber: 5\n  }, this)]\n}, void 0, true, {\n  fileName: _jsxFileName,\n  lineNumber: 9,\n  columnNumber: 3\n}, this);\n\n// console.log(Comp)\n\nconst root = {\n  stateNode: document.getElementById('root'),\n  props: {\n    children: [Comp]\n  }\n};\nlet nextUnitOfWork = root;\n// 从虚拟DOM跟节点进行遍历，如有浏览器有空闲时间，将进行fiber 节点构建，如果没有，则暂停构建，但nextUnitWork停留在上一次构建的节点\nconst workLoop = deadline => {\n  while (nextUnitOfWork && deadline.timeRemaining() > 0) {\n    nextUnitOfWork = performanceUnitOfWork(nextUnitOfWork);\n  }\n  if (!nextUnitOfWork) {\n    console.log(root);\n  }\n};\n\n// TODO: 1.构建真实dom 当不会添加到页面上， 2 构建fiber 结构为 主要结构  {return, child, sibling, props, effectTag, type}\nconst beginWork = workingInProgressFiber => {\n  // 没有真实dom 创建真实dom\n  if (!workingInProgressFiber.stateNode) {\n    workingInProgressFiber.stateNode = document.createElement(workingInProgressFiber.type);\n    for (let key in workingInProgressFiber.props) {\n      // 简单出来将 props 值调添加到dom\n      if (key !== 'children') workingInProgressFiber.stateNode[key] = workingInProgressFiber.props[key];\n    }\n  }\n  console.log(workingInProgressFiber.props);\n  if (Array.isArray(workingInProgressFiber.props.children)) {\n    debugger;\n    let previousFiber; // 记录上个fiber 节点\n    workingInProgressFiber.props.children.forEach((child, index) => {\n      // 构建fiber节点信息\n      const childFiber = {\n        type: child.type,\n        props: child.props,\n        return: workingInProgressFiber,\n        effectTag: 'PLACEMENT'\n      };\n      // 第一元素 是孩子\n      if (index === 0) {\n        workingInProgressFiber.child = childFiber;\n      } else {\n        previousFiber.sibling = childFiber;\n      }\n      previousFiber = childFiber;\n    });\n  }\n};\nconst performanceUnitOfWork = workingInProgressFiber => {\n  beginWork(workingInProgressFiber);\n  // fiber 遍历顺序是 先孩子在sibling 然后到return\n  if (workingInProgressFiber.child) {\n    return workingInProgressFiber.child;\n  }\n  while (workingInProgressFiber) {\n    // 如果有兄弟节点 返兄弟节点\n    if (workingInProgressFiber.sibling) {\n      return workingInProgressFiber.sibling;\n    }\n    // 没有兄弟节点 回到父级，重新进度while递归 找父级节点的兄弟\n    workingInProgressFiber = workingInProgressFiber.return;\n  }\n};\nrequestIdleCallback(workLoop);","map":{"version":3,"names":["Comp","_jsxDEV","id","children","fileName","_jsxFileName","lineNumber","columnNumber","root","stateNode","document","getElementById","props","nextUnitOfWork","workLoop","deadline","timeRemaining","performanceUnitOfWork","console","log","beginWork","workingInProgressFiber","createElement","type","key","Array","isArray","previousFiber","forEach","child","index","childFiber","return","effectTag","sibling","requestIdleCallback"],"sources":["/Users/wujiamian/Desktop/shouxie/mini-react/src/index.js"],"sourcesContent":["// fiber执行阶段\n// 每次渲染都有两个阶段 reconcilation 跟 commit 阶段\n// reconciler： 是diff算法阶段，可以被中断，会找出所有节点的变更\n// 比如节点删除 更新 新增 属性变化， 称为react的副作用\n\n// 提交阶段：将上个阶段计算出来的副作用一次性执行，是同步\n\nconst Comp = (\n  <div id=\"compId\">\n    <p id=\"text1\">\n      text1\n      <p id=\"text1-1\">text1-1</p>\n    </p>\n    <p id=\"text2\">text2</p>\n  </div>\n)\n\n// console.log(Comp)\n\nconst root = {\n  stateNode: document.getElementById('root'),\n  props: {children: [Comp]}\n}\n\nlet nextUnitOfWork = root\n// 从虚拟DOM跟节点进行遍历，如有浏览器有空闲时间，将进行fiber 节点构建，如果没有，则暂停构建，但nextUnitWork停留在上一次构建的节点\nconst workLoop = (deadline) => {\n\n  while (nextUnitOfWork && deadline.timeRemaining() > 0) {\n    nextUnitOfWork = performanceUnitOfWork(nextUnitOfWork)\n  }\n  if(!nextUnitOfWork) {\n    console.log(root)\n  }\n}\n\n// TODO: 1.构建真实dom 当不会添加到页面上， 2 构建fiber 结构为 主要结构  {return, child, sibling, props, effectTag, type}\nconst beginWork = (workingInProgressFiber) => {\n\n  // 没有真实dom 创建真实dom\n  if (!workingInProgressFiber.stateNode) {\n    workingInProgressFiber.stateNode = document.createElement(workingInProgressFiber.type)\n    for (let key in workingInProgressFiber.props) {\n      // 简单出来将 props 值调添加到dom\n      if (key !== 'children') workingInProgressFiber.stateNode[key] = workingInProgressFiber.props[key]\n    }\n  }\n  console.log(workingInProgressFiber.props)\n  if (Array.isArray(workingInProgressFiber.props.children)) {\n    debugger\n    let previousFiber; // 记录上个fiber 节点\n    workingInProgressFiber.props.children.forEach((child, index) => {\n      // 构建fiber节点信息\n      const childFiber = {\n        type: child.type,\n        props: child.props,\n        return: workingInProgressFiber,\n        effectTag: 'PLACEMENT'\n      }\n      // 第一元素 是孩子\n      if (index === 0) {\n        workingInProgressFiber.child = childFiber\n      } else {\n        previousFiber.sibling = childFiber\n      }\n      previousFiber = childFiber\n    });\n  }\n}\nconst performanceUnitOfWork = (workingInProgressFiber) => {\n  beginWork(workingInProgressFiber)\n  // fiber 遍历顺序是 先孩子在sibling 然后到return\n  if(workingInProgressFiber.child) {\n    return  workingInProgressFiber.child\n  }\n  while(workingInProgressFiber) {\n    // 如果有兄弟节点 返兄弟节点\n    if(workingInProgressFiber.sibling) {\n      return workingInProgressFiber.sibling\n    }\n  // 没有兄弟节点 回到父级，重新进度while递归 找父级节点的兄弟\n    workingInProgressFiber =  workingInProgressFiber.return\n  }\n}\n\nrequestIdleCallback(workLoop)"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}